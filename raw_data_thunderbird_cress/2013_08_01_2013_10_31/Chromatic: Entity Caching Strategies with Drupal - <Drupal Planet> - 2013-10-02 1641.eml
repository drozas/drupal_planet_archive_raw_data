X-Mozilla-Status: 0041
X-Mozilla-Status2: 00000000
X-Mozilla-Keys:                                                                                
Date: Wed, 02 Oct 2013 15:41:28 +0000
Message-Id: <http://drupal.org/planet/rss.xml#Wed, 02 Oct 2013 15:41:28 +0000@localhost.localdomain>
From: <Drupal Planet>
MIME-Version: 1.0
Subject: Chromatic: Entity Caching Strategies with Drupal
Content-Transfer-Encoding: 8bit
Content-Base: http://www.chromaticsites.com/blog/entity-caching-strategies-drupal
Content-Type: text/html; charset=UTF-8

<html>
  <head>
    <title>Chromatic: Entity Caching Strategies with Drupal</title>
    <base href="http://www.chromaticsites.com/blog/entity-caching-strategies-drupal">
  </head>
  <body id="msgFeedSummaryBody" selected="false">
    <div class="field field-name-body field-type-text-with-summary field-label-hidden">
              <p>There comes a time where you sit back and look at your Drupal site and realize that you've created a monster. You try to refactor your code, but there is only so much you can do, as there is genuine level of complexity behind how all of your different node types render out their fields. Or, perhaps your site isn't complicated, but has been ground to a halt by the sheer number of entities that must be loaded to render a single page.</p>
<p>Doubtless, you've heard of caching once or twice, but your caching strategy gets complicated when you're rendering nodes on dynamic pages, such as a View with exposed filters or search results where the entire output of a page is almost always unique. However, the individual entities stay the same, or at least until they are changed, and whenever something stays the same the opportunity for caching is introduced. Let me show you how it’s done.</p>
<h3>Load Caching</h3>
<p>One of the first steps in displaying any content is retrieving the information from the database. Normally this isn't a problem, but as your entities increase in complexity with additional fields, the queries required to return a fully structured entity can turn into a bottleneck on your site. This is where <a href="https://drupal.org/project/entitycache">Entity cache</a> comes into play. It utilizes the new Drupal 7 entity API to cache entire entities, thus removing the need to perform time consuming queries. Win!</p>
<p>There is one catch to this approach, it requires that you always update your entity tables using the save/delete API calls in order to ensure Entity cache knows when to invalidate the cache. But you are doing that already, right?</p>
<p>This technique can be further enhanced by using the the <a href="https://drupal.org/project/drush_ecl">Drush Entity Cache Loader</a> module, which provides a command line interface that allows you to prime your entity cache all at once or by entity type.</p>
<h3>Render Caching</h3>
<p>With our entities safely cached and ready to go, we now turn our attention to the theme layer where we have to create a render array and run through our often time consuming preprocess logic for every entity. This is where <a href="https://drupal.org/project/display_cache">Display Cache</a> cache comes in to help us out. Display Cache only reports a few site installs at the moment, but it appears to be a solid module that anyone who needs this functionality should look into using and supporting. It offers controls on a per node type basis, in addition to allowing controls for individual fields within each node type. We haven't used Display Cache beyond testing at the moment, but we will definitely be looking into it the next time a need like this arises.</p>
<p>It should be noted that Display Cache is only available for Drupal 7, and many large websites will probably continue to use D6 for another couple years. To bridge the gap, the <a href="https://drupal.org/project/advcache">Advanced cache</a> module offers somewhat similar functionality for D6, but it only has a dev release and doesn't have any recent activity. Additionally, the custom solution outlined below could be extended to offer Display cache like functionality for Drupal 6.</p>
<h3>Views Caching</h3>
<p>We are getting to a good place now, our entities are cached along with their rendered markup for various view modes. However, <a href="https://drupal.org/project/views_content_cache">Views content cache</a> allows us to take caching one step further. While it is only in alpha at the time of this writing, in testing it offered powerful and easy to use controls that allow for cache control on a per view basis. It offers cache invalidation by node type and max/min cache times for the query set results as well as the full rendered markup of the view, which gives you another layer of caching with great invalidation controls. There is one caveat to this module. As noted in the <a href="https://drupal.org/node/871274">documentation</a>, it doesn't support views with exposed filters due to an outstanding <a href="https://drupal.org/node/1055616">issue</a> with views.</p>
<h3>Custom Solutions</h3>
<p>With the incredible solutions above, is there even a need to implement a custom caching solution for any of these layers? The answer is probably "no" for most, but we needed a way to cache the rendered markup from some lengthy preprocess functions for search results in Drupal 6. The core functionality from our implementation is included below for any of you who think you may need a custom solution.</p>
<h3>Alter the theme registry</h3>
<p>First we need to alter the theme registry a bit. We do this by cloning our existing theme entry (for later use) and overriding it with a new entry that uses a function as the callback instead of a template file. This is probably the most important step, as it completely hides the caching functionality from the rest of Drupal. This allows you to still use the theme layer without Drupal ever knowing about the magic happening in the background.</p>
<pre class="prettyprint"><code>/**<br /> * Implements hook_theme_registry_alter().<br /> */<br />function example_theme_registry_alter(&amp;$theme_registry){<br />  // Duplicate the standard node theme entry.<br />  $theme_registry['node_copy'] = $theme_registry['node'];<br />  // Overwrite the existing node theme entry.<br />  $theme_registry['node'] = array(<br />    'function' =&gt; 'example_render_template',<br />    'theme path' =&gt; path_to_theme(),<br />    'type' =&gt; 'module',<br />    'render element' =&gt; 'elements',<br />  );<br />}</code></pre><h3>Set up a theme callback function</h3>
<p>This function now returns the fully rendered markup for a node, since we are no longer rendering the node through a template.</p>
<pre class="prettyprint"><code>/**<br /> * Callback theming function for nodes.<br /> *<br /> * @param $variables<br /> *   An array on theme variables.<br /> *<br /> * @return<br /> *   The fully rendered node markup.<br /> */<br />function example_render_template($variables) {<br />  $markup = '';<br />  // Get the node object.<br />  $node = $variables['elements']['#node'];<br />  // Get the cache id.<br />  $cache_id = example_cache_id($node);<br />  // The cache exists and is valid.<br />  if (($cache = cache_get($cache_id, 'cache_node')) &amp;&amp; !empty($cache-&gt;data)) {<br />    $markup = $cache-&gt;data;<br />  }<br />  // Render out a new node.<br />  else {<br />    // Render the node.<br />    $markup = theme('node_copy', $variables);<br />    // Delete the old cached values.<br />    $cache_id_delete = sprintf('node_%d', $node-&gt;nid);<br />    cache_clear_all($cache_id_delete, 'cache_node', TRUE);<br />    // Cache the rendered markup.<br />    cache_set($cache_id, $markup, 'cache_node');<br />  }<br />  return $markup;<br />}</code></pre><h3>Create cache id values</h3>
<p>The trick that makes this all work is the inclusion of the node's vid in the cache id. This ensures that a stale cache value will never be accessed, eliminating the need to trigger a cache invalidation each time a node is updated.</p>
<pre class="prettyprint"><code>/**<br /> * Creates a cache id for a given node.<br /> * Format: node_[nid]_[vid].<br /> * <br /> * @param $node<br /> *   A standard Drupal node object.<br /> * <br /> * @return<br /> *   The current cache id for the node or FALSE if unsuccessful.<br /> */<br />function example_cache_id($node) {<br />  // Ensure that a nid is available.<br />  if (!isset($node-&gt;nid)) {<br />    watchdog('Error getting the cache id because no nid could be found.');<br />    return FALSE;<br />  }<br />  // Create and return the cache id.<br />  $cache_id = sprintf('node_%d_%d', $node-&gt;nid, $node-&gt;vid);<br />  return $cache_id;<br />}</code></pre><h3>Add cache clearing and drush integration</h3>
<p>Since we created a new cache table, we now need to register a new cache clearing function to allow the cache to be cleared from within the Drupal UI. While we are at it, we add drush hooks so the new cache table can be cleared via drush as well.</p>
<pre class="prettyprint"><code>/**<br /> * Implements hook_drush_cache_clear().<br /> */<br />function example_drush_cache_clear(&amp;$types) {<br />  $types['node'] = 'example_cache_clear_all';<br />}<br /><br />/**<br /> * Callback function for @see hook_drush_cache_clear.<br /> */<br />function example_cache_clear_all() {<br />  cache_clear_all('*', 'cache_node', TRUE);<br />}<br /><br />/**<br /> * Implements hook_flush_caches().<br /> */<br />function example_flush_caches() {<br />  return array('cache_node');<br />}</code></pre><p>
So whether you implement something custom or utilize one or all of the modules outlined above, we hope we have opened your eyes to a new layer of caching that you can add to your site to make it even faster. However, we would be remiss if we did not mention that this isn't a full caching solution. Even with all of this in place, there is still plenty of room for memcache, APC, varnish, and all of the other caching tools that are available. So cache early and cache often, just make sure you invalidate your cache correctly along the way.</p>
          </div>
  </body>
</html>

