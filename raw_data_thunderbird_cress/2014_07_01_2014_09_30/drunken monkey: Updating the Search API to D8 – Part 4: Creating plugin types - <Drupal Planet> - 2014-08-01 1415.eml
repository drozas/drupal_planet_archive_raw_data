X-Mozilla-Status: 0041
X-Mozilla-Status2: 00000000
X-Mozilla-Keys:                                                                                
Date: Fri, 01 Aug 2014 13:15:16 +0000
Message-Id: <http://drupal.org/planet/rss.xml#Fri, 01 Aug 2014 13:15:16 +0000@localhost.localdomain>
From: <Drupal Planet>
MIME-Version: 1.0
Subject: drunken monkey: Updating the Search API to D8 – Part 4: Creating plugin types
Content-Transfer-Encoding: 8bit
Content-Base: http://drunkenmonkey.at/blog/search-api-d8-update-part-4
Content-Type: text/html; charset=UTF-8

<html>
  <head>
    <title>drunken monkey: Updating the Search API to D8 – Part 4: Creating plugin types</title>
    <base href="http://drunkenmonkey.at/blog/search-api-d8-update-part-4">
  </head>
  <body id="msgFeedSummaryBody" selected="false">
    <div class="field field-name-field-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item even"><img typeof="foaf:Image" src="http://drunkenmonkey.at/sites/default/files/styles/medium/public/field_image/plugins.png?itok=bzW_UOnu" width="96" height="96" alt="" title="This time in the &quot;Updating to Drupal 8&quot; series: plugins." /></div></div></div><div class="field field-name-body field-type-text-with-summary field-label-hidden"><div class="field-items"><div class="field-item even" property="content:encoded"><p>The new plugin system is another large and important change in Drupal 8. While you were pretty much on your own if you wanted to provide some kind of plugin system in Drupal 7 (which a lot of modules do – think Views, Rules, etc.) there is now a very sophisticated framework to easily implement plugins and to define your own plugin types in a clean, extensible and very flexible way. And the good news for everyone familiar (code-wise) with the Search API in Drupal 7: the system is very much in line with how Search API implemented plugins itself, so the switch is pretty easy for us.</p>
<h2>What is a plugin?</h2>
<p>There have already been a lot of great blog posts about the plugin system in Drupal 8, so I won't go into much detail here. Generally speaking, a plugin is a self-contained unit providing a certain, well-defined functionality. A plugin type is defined by a single, central system (which is usually also the only place where the plugins are used), but other modules can then provide their own plugins with an individual implementation of that functionality.</p>
<p>Probably not a very helpful explanation, it's not that easy to explain – but, to use an example, blocks are now plugins in Drupal 8. The Block module provides the "Block" plugin type, which defines how blocks can be displayed on a page and how they can be configured. The Block module also provides all the code utilizing those plugins, letting the user place blocks on the site, ensuring they are displayed when and where appropriate, etc. Other modules then provide implementations of that "Block" plugin type – i.e., individual plugins – that implement different kinds of blocks: the User module provides a block with the login form, the Language module the "Language switcher" block, the Book module a block displaying the current book's navigation, etc.<br />
But there are literally dozens of other types of plugins already included in Drupal core, and contrib is bound to add countless more – four (currently) by the Search API, for example. Entity types, the various Views handlers (fields, filters, sorts, …) and plugins (display, row, …), field types, WYSIWYG editors – all of those are now just different types of plugins, all using one new, large, unified framework to provide their functionality.</p>
<h2>Ingredients for a new plugin type</h2>
<p>So, what do we need to add our own plugin type to that growing list? Well, basically just a plugin manager, which (as <a href="/blog/search-api-d8-update-part-3">explained last time</a>) is a special type of service – that's it. Your new plugin type becomes available by just implementing a single method. Of course, to make your plugin type more useful and easier to use for others, you should add a few more things: an interface describing what plugins of that type should be able to do, an abstract base class for implementing that interface (unless it doesn't make sense in your case) and (optionally) a dedicated annotation for your plugin type.</p>
<p>Let's go through those with the example of Search API processors.</p>
<h3>The plugin manager</h3>
<p>As mentioned earlier, the plugin manager is simply a special kind of service. There is a base class (<span title="\Drupal\Core\Plugin\DefaultPluginManager"><code>DefaultPluginManager</code></span>) which already takes care of 95% of what's needed, you literally only need to override the constructor. So, we save the following in <a href="http://cgit.drupalcode.org/sandbox-daeron-2091893/tree/src/Processor/ProcessorPluginManager.php"><code>search_api/src/Processor/ProcessorPluginManager.php</code></a>:</p>
<div class="codeblock">
<pre><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br /></span><span style="color: #007700">class </span><span style="color: #0000BB">ProcessorPluginManager </span><span style="color: #007700">extends </span><span style="color: #0000BB">DefaultPluginManager </span><span style="color: #007700">{<br /><br />  public function </span><span style="color: #0000BB">__construct</span><span style="color: #007700">(\</span><span style="color: #0000BB">Traversable $namespaces</span><span style="color: #007700">, </span><span style="color: #0000BB">CacheBackendInterface $cache_backend</span><span style="color: #007700">, </span><span style="color: #0000BB">ModuleHandlerInterface $module_handler</span><span style="color: #007700">) {<br />    </span><span style="color: #0000BB">parent</span><span style="color: #007700">::</span><span style="color: #0000BB">__construct</span><span style="color: #007700">(</span><span style="color: #DD0000">'Plugin/search_api/processor'</span><span style="color: #007700">, </span><span style="color: #0000BB">$namespaces</span><span style="color: #007700">, </span><span style="color: #0000BB">$module_handler</span><span style="color: #007700">, </span><span style="color: #DD0000">'Drupal\search_api\Annotation\SearchApiProcessor'</span><span style="color: #007700">);<br />    </span><span style="color: #0000BB">$this</span><span style="color: #007700">-&gt;</span><span style="color: #0000BB">setCacheBackend</span><span style="color: #007700">(</span><span style="color: #0000BB">$cache_backend</span><span style="color: #007700">, </span><span style="color: #DD0000">'search_api_processors'</span><span style="color: #007700">);<br />    </span><span style="color: #0000BB">$this</span><span style="color: #007700">-&gt;</span><span style="color: #0000BB">alterInfo</span><span style="color: #007700">(</span><span style="color: #DD0000">'search_api_processor_info'</span><span style="color: #007700">);<br />  }<br /><br />}<br /></span><span style="color: #0000BB">?&gt;</span></span></code></pre></div>
<p>(To save space, I skip the namespace, imports and comments for all examples.)<br />
This can be used as kind of a template, the base class will then take care of everything that's necessary to make the plugin system work. Here's what each of the lines do:</p>
<ul><li>The <code>__construct()</code> method signature contains the service's dependencies, which will be injected when the plugin manager is constructed. <code>$namespaces</code> basically contains all root folders for sub-namespaces – i.e., every module's <code>src/</code> and/or <code>lib/</code> directory, plus a few more. The others are the services that handle caching and module interaction (e.g., invoking hooks).</li>
<li>The parent constructor sets the plugin manager up for this specific plugin type. The two variables are of course just passed on as-is, the other two parameters represent the following:
<ul><li><code>Plugin/search_api/processor</code> is the sub-dir (and therefore sub-namespace) in which plugins of this type have to be located for automatic detection. That means, e.g., if the Views module would want to provide a Search API processor, it would have to be in namespace <code>\Drupal\views\Plugin\search_api\processor</code>, otherwise it wouldn't be found.<br />
      The general standard for this parameter is either <code>Plugin/[module]/[component]</code> (like here) or <code>Plugin/[ModuleComponent]</code> (so, <code>Plugin/SearchApiProcessor</code> in this case). I think the former is generally preferred if your module defines more than one plugin type, while the latter can be cleaner/more practical if your module only defines a single one – I'm not completely sure myself, though. They probably shouldn't be mixed in a single module, in any case.<br />
      (As a side note, I cheated here a bit, we currently use the sub-dir <code>Plugin/SearchApi/Processor</code> for processors. As I'm pretty sure that's wrong, though, <a href="https://www.drupal.org/node/2252421">we'll change that shortly</a>.)</li>
<li><code>\Drupal\search_api\Annotation\SearchApiProcessor</code> is the fully qualified class name of the annotation that will be used for defining plugins of your type. (<a href="https://www.drupal.org/node/1882526">See here</a> if you have no idea what I'm talking about.) You can just skip this parameter, in which case it will default to <code>\Drupal\Component\Annotation\Plugin</code> – i.e., the generic <code>@Plugin</code> annotation. Core's validation constraints, e.g., use this instead of an individual annotation. Don't ask me what the decision process is here, but I'm pretty sure it's generally encouraged to use a dedicated annotation for your plugin types.</li>
</ul></li>
<li>The second line just sets up caching for the plugin type, to avoid having to re-discover the available plugins each time they are required. <code>search_api_processors</code> here is the cache key that will be used to store the cached entries. You can also pass an array of cache tags as an optional third parameter to <code>setCacheBackend()</code>, which can be useful in special scenarios (i.e., when the cached plugin data should always be cleared alongside other cached data) but usually shouldn't be done.</li>
<li>The last line just determines that modules can alter the available processor definitions using <code>hook_search_api_processor_info_alter(array &amp;$definitions)</code>. Make sure to also document that hook in your module's <code>MODULE.api.php</code> file!</li>
</ul><p>And that's already it for the class, all very straight-forward. Now, the only thing that's missing for the service is its entry in the <a href="http://cgit.drupalcode.org/sandbox-daeron-2091893/tree/search_api.services.yml"><code>search_api.services.yml</code></a> file:</p>
<div class="codeblock"><code>services:<br />  plugin.manager.search_api.processor:<br />    class: Drupal\search_api\Processor\ProcessorPluginManager<br />    parent: default_plugin_manager</code></div>
<p>The service ID here is generally <code>plugin.manager.[module].[component]</code>. Then we simply specify the class we just created and use the handy <code>parent</code> shortcut to copy over the same constructor dependencies that (usually) all plugin managers have. This is no higher magic but just references (and partly copies over) the following definition from <a href="http://cgit.drupalcode.org/drupal/tree/core/core.services.yml?h=8.0.x"><code>core.services.yml</code></a>:</p>
<div class="codeblock"><code>services:<br />  default_plugin_manager:<br />    abstract: true<br />    arguments: ['@container.namespaces', '@cache.discovery', '@module_handler']</code></div>
<p>You'll recognize the arguments as exactly those we used in our plugin manager's constructor.</p>
<h3>The <code>@SearchApiProcessor</code> annotation</h3>
<p>Since we wanted a dedicated annotation instead of the generic <code>@Plugin</code>, we still have to create the <span title="\Drupal\search_api\Annotation\SearchApiProcessor"><code>SearchApiProcessor</code></span> annotation class to get the plugin type basically working. This is also very easy, we just put the following into <a href="http://cgit.drupalcode.org/sandbox-daeron-2091893/tree/src/Annotation/SearchApiProcessor.php"><code>search_api/src/Annotation/SearchApiProcessor.php</code></a>:</p>
<div class="codeblock">
<pre><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br /></span><span style="color: #007700">class </span><span style="color: #0000BB">SearchApiProcessor </span><span style="color: #007700">extends </span><span style="color: #0000BB">Plugin </span><span style="color: #007700">{<br /><br />  public </span><span style="color: #0000BB">$id</span><span style="color: #007700">;<br /><br />  public </span><span style="color: #0000BB">$label</span><span style="color: #007700">;<br /><br />  public </span><span style="color: #0000BB">$description</span><span style="color: #007700">;<br /><br />}<br /></span><span style="color: #0000BB">?&gt;</span></span></code></pre></div>
<p>That's all – you just define your plugin annotation's properties and inherit from <span title="\Drupal\Component\Annotation\Plugin"><code>Plugin</code></span>, that base class will take care of everything else. The properties aren't even necessary, they are just there to document for other developers what properties the plugin type expects in plugin definitions. (And, though not used in this case, to set defaults for optional properties.) The base class doesn't care about that, it will just save all the properties it encounters in the definition, regardless of whether they are defined or not. (Note, though, that the <code>id</code> property is "magic" – if you want to use that for anything other than the plugin ID (and have the plugin ID in a different property), then you'll have to override <code>getId()</code> in your annotation class.)<br />
The only thing you do have to take care of is that annotation autloading will only work if you put the annotation into the <code>\Drupal\[module]\Annotation</code> namespace.</p>
<h3>The plugin interface and base class</h3>
<p>With the above done, you already have a fully functional new plugin type: other modules can define their own Search API processors and we can easily get all defined processors with the following bit of code:</p>
<div class="codeblock">
<pre><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br />$processor_plugin_manager </span><span style="color: #007700">= \</span><span style="color: #0000BB">Drupal</span><span style="color: #007700">::</span><span style="color: #0000BB">service</span><span style="color: #007700">(</span><span style="color: #DD0000">'plugin.manager.search_api.processor'</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">$processor_definitions </span><span style="color: #007700">= </span><span style="color: #0000BB">$processor_plugin_manager</span><span style="color: #007700">-&gt;</span><span style="color: #0000BB">getDefinitions</span><span style="color: #007700">();<br />foreach (</span><span style="color: #0000BB">$processor_definitions </span><span style="color: #007700">as </span><span style="color: #0000BB">$processor_id </span><span style="color: #007700">=&gt; </span><span style="color: #0000BB">$processor_definition</span><span style="color: #007700">) {<br />  </span><span style="color: #0000BB">$processors</span><span style="color: #007700">[</span><span style="color: #0000BB">$processor_id</span><span style="color: #007700">] = </span><span style="color: #0000BB">$processor_plugin_manager</span><span style="color: #007700">-&gt;</span><span style="color: #0000BB">createInstance</span><span style="color: #007700">(</span><span style="color: #0000BB">$processor_id</span><span style="color: #007700">, </span><span style="color: #0000BB">$processor_settings</span><span style="color: #007700">[</span><span style="color: #0000BB">$processor_id</span><span style="color: #007700">]);<br />}<br /></span><span style="color: #0000BB">?&gt;</span></span></code></pre></div>
<p>However, while this is a complete working example as far as Drupal's plugin framework is concerned, it is of course not really practical since we don't specify anywhere what we expect from processor plugins, so modules that want to provide their own processors don't know which methods to provide and how they should behave (without combing the whole module code of the Search API for any calls to processor plugins). So, it is more or less required to also define an interface for plugins of your new type that implementing modules would have to use.</p>
<p>The specific methods in the interface of course differ from case to case, but there are a lot of interfaces (and corrsponding base classes or traits) provided in Drupal Core for functionality that is often required for plugins. E.g., <span title="\Drupal\Component\Plugin\PluginInspectionInterface"><code>PluginInspectionInterface</code></span> lets you retrieve a plugin's ID and definition, <span title="\Drupal\Component\Plugin\DerivativeInspectionInterface"><code>DerivativeInspectionInterface</code></span> helps dealing with plugin derivatives (look out for an upcoming blog post about those) and <span title="\Drupal\Core\Plugin\PluginBase"><code>PluginBase</code></span> is a great base class for plugins which implements both of these interfaces and additionally provides a few other handy methods for child classes (first and foremost, a <code>t()</code> method for doing dependency-injected translation). <span title="\Drupal\Core\Plugin\PluginFormInterface"><code>PluginFormInterface</code></span> provides methods for plugins that should have a configuration form, usually used in conjunction with <span title="\Drupal\Component\Plugin\ConfigurablePluginInterface"><code>ConfigurablePluginInterface</code></span>, which represents plugins with configuration. And <span title="\Drupal\Core\Plugin\ContainerFactoryPluginInterface"><code>ContainerFactoryPluginInterface</code></span>, as the last one used in the Search API, provides a static <code>create()</code> method for easily implementing proper dependency injection. There are more, though, so take a look through the <code>\Drupal\Component\Plugin</code> and <code>\Drupal\Core\Plugin</code> namespaces before adding custom methods to your plugin interface.</p>
<p>The whole interface then looks like this (conceptually):</p>
<div class="codeblock">
<pre><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br /></span><span style="color: #007700">interface </span><span style="color: #0000BB">ProcessorInterface </span><span style="color: #007700">extends </span><span style="color: #0000BB">PluginInspectionInterface</span><span style="color: #007700">, </span><span style="color: #0000BB">DerivativeInspectionInterface</span><span style="color: #007700">, </span><span style="color: #0000BB">DrupalConfigurablePluginInterface</span><span style="color: #007700">, </span><span style="color: #0000BB">PluginFormInterface</span><span style="color: #007700">, </span><span style="color: #0000BB">ContainerFactoryPluginInterface </span><span style="color: #007700">{<br /><br />  </span><span style="color: #FF8000">// Put plugin type-specific methods here.<br /><br /></span><span style="color: #007700">}<br /></span><span style="color: #0000BB">?&gt;</span></span></code></pre></div>
<p>This interface is usually put into the same directory (and, therefore, namespace) as the plugin manager (since there is nothing else that really links the plugin manager to the interface), as is a default base class for the plugin type that implements the interface and helps modules avoid boilerplate code when providing their own plugins:</p>
<div class="codeblock">
<pre><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br /></span><span style="color: #007700">abstract class </span><span style="color: #0000BB">ProcessorPluginBase </span><span style="color: #007700">extends </span><span style="color: #0000BB">PluginBase </span><span style="color: #007700">implements </span><span style="color: #0000BB">ProcessorInterface </span><span style="color: #007700">{<br /><br />  </span><span style="color: #FF8000">// Here, provide default implementations for all methods of the interface (for which it makes sense).<br /><br /></span><span style="color: #007700">}<br /></span><span style="color: #0000BB">?&gt;</span></span></code></pre></div>
<p>And that's all, now you've completely defined a new plugin type for your module. Modules can now provide plugins of that type like this:</p>
<div class="codeblock">
<pre><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br /></span><span style="color: #FF8000">/**<br /> * @SearchApiProcessor(<br /> *   id = "example_some_processor",<br /> *   label = @Translation("Some processor"),<br /> *   description = @Translation("Description of the processor.")<br /> * )<br /> */<br /></span><span style="color: #007700">class </span><span style="color: #0000BB">SomeProcessor </span><span style="color: #007700">extends </span><span style="color: #0000BB">ProcessorPluginBase </span><span style="color: #007700">{<br /><br />  </span><span style="color: #FF8000">// Plugin code.<br /><br /></span><span style="color: #007700">}<br /></span><span style="color: #0000BB">?&gt;</span></span></code></pre></div>
<p><small>Image credit: <a href="http://findicons.com/icon/175726/diagram_v2_10?id=270188">findicons.com</a></small></p>
</div></div></div>
  </body>
</html>

