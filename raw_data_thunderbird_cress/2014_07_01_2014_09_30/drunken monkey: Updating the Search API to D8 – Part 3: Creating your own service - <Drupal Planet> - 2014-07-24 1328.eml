X-Mozilla-Status: 0041
X-Mozilla-Status2: 00000000
X-Mozilla-Keys:                                                                                
Date: Thu, 24 Jul 2014 12:28:15 +0000
Message-Id: <http://drupal.org/planet/rss.xml#Thu, 24 Jul 2014 12:28:15 +0000@localhost.localdomain>
From: <Drupal Planet>
MIME-Version: 1.0
Subject: drunken monkey: Updating the Search API to D8 – Part 3: Creating your own service
Content-Transfer-Encoding: 8bit
Content-Base: http://drunkenmonkey.at/blog/search-api-d8-update-part-3
Content-Type: text/html; charset=UTF-8

<html>
  <head>
    <title>drunken monkey: Updating the Search API to D8 – Part 3: Creating your own service</title>
    <base href="http://drunkenmonkey.at/blog/search-api-d8-update-part-3">
  </head>
  <body id="msgFeedSummaryBody" selected="false">
    <div class="field field-name-body field-type-text-with-summary field-label-hidden"><div class="field-items"><div class="field-item even" property="content:encoded"><p>Even though there was somewhat of a delay since <a href="/blog/search-api-d8-update-part-2">my last post in this series</a>, it seems no-one else has really covered any of the advanced use cases of Drupal 8 in tutorials yet. So, here is the next installment in my series. I initially wanted to cover creating a new plugin type, but since that already requires creating a new servive, I thought I'd cover that smaller part first and then move on to plugin types in the next post.<br />
I realize that now already a lot more people have started on their Drupal 8 modules, but perhaps this will make this series all the more useful.</p>
<h2>Services in Drupal 8</h2>
<p>First, a short overview of what a service even is. Basically it is a component (represented as a class) providing a certain, limited range of functionality. The database is a service, the entity manager (which is what you now use for loading entities) is a service, translation, configuration – everything handled by services. Getting the current user – also a service now, ridding us of the highly unclean global variable.<br />
In general, a lot of what was previously a file in <code>includes/</code> containing some functions with a common prefix is now a service (or split into multiple services).</p>
<p>The upsides of this is that the implementation and logic is cleanly bundled and properly encapsulated, that all these components can easily be switched out by contrib or later core updates, and that these systems can also be very well tested with unit tests. Even more, since services can be used with dependency injection, it also makes it much easier to test all other classes that use any of these services (if they can use dependency injection and do it properly).</p>
<p>(For reference, here is the <a href="https://www.drupal.org/node/2133171">official documentation on services</a>.)</p>
<h3>Dependency injection</h3>
<p>This has been covered already in a lot of other blog posts, probably since it is both a rather central concept in Drupal 8, and a bit complicated when you first encounter it. However, before using it, I should still at least skim over the topic. Feel free to skip to the next heading if you feel you already know what dependency injection is and how it roughly works in Drupal 8.</p>
<p>Dependency injection is a programming technique where a class with external dependencies (e.g., a mechanism for translating) explicitly defines these dependencies (in some form) and makes the class which constructs it responsible for supplying those dependencies. That way, the class itself can be self-contained and doesn't need to know about where it can get those dependencies, or use any global functions or anything to achieve that.</p>
<p>Consider for example the following class:</p>
<div class="codeblock">
<pre><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br /></span><span style="color: #007700">class </span><span style="color: #0000BB">ExampleClass </span><span style="color: #007700">{<br /><br />  public function </span><span style="color: #0000BB">getDefinition</span><span style="color: #007700">() {<br />    return array(<br />      </span><span style="color: #DD0000">'label' </span><span style="color: #007700">=&gt; </span><span style="color: #0000BB">t</span><span style="color: #007700">(</span><span style="color: #DD0000">'example class'</span><span style="color: #007700">),<br />      </span><span style="color: #DD0000">'type' </span><span style="color: #007700">=&gt; </span><span style="color: #DD0000">'foo'</span><span style="color: #007700">,<br />    );<br />  }<br /><br />}<br /></span><span style="color: #0000BB">?&gt;</span></span></code></pre></div>
<p>For translating the definition label, this explicitly uses the global <code>t()</code> function. Now, what's bad about this I, hear you ask, it worked well enough in Drupal 7, right?<br />
The problem is that it becomes almost impossible to properly unit-test that method without bootstrapping Drupal to the point where the <code>t()</code> function becomes available and functional. It's also more or less impossible to switch out Drupal's translation mechanism without hacking core, since there is no way to redirect the call to <code>t()</code>.</p>
<p>But if translation is done by a class with a defined interface (in other words, a service), it 's possible to do this much cleaner:</p>
<div class="codeblock">
<pre><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br /></span><span style="color: #007700">class </span><span style="color: #0000BB">ExampleClass </span><span style="color: #007700">{<br /><br />  public function </span><span style="color: #0000BB">__construct</span><span style="color: #007700">(</span><span style="color: #0000BB">TranslationServiceInterface $translation</span><span style="color: #007700">) {<br />    </span><span style="color: #0000BB">$this</span><span style="color: #007700">-&gt;</span><span style="color: #0000BB">translation </span><span style="color: #007700">= </span><span style="color: #0000BB">$translation</span><span style="color: #007700">;<br />  }<br /><br />  public function </span><span style="color: #0000BB">getDefinition</span><span style="color: #007700">() {<br />    return array(<br />      </span><span style="color: #DD0000">'label' </span><span style="color: #007700">=&gt; </span><span style="color: #0000BB">$this</span><span style="color: #007700">-&gt;</span><span style="color: #0000BB">translation</span><span style="color: #007700">-&gt;</span><span style="color: #0000BB">translate</span><span style="color: #007700">(</span><span style="color: #DD0000">'example class'</span><span style="color: #007700">),<br />      </span><span style="color: #DD0000">'type' </span><span style="color: #007700">=&gt; </span><span style="color: #DD0000">'foo'</span><span style="color: #007700">,<br />    );<br />  }<br /><br />}<br /></span><span style="color: #0000BB">?&gt;</span></span></code></pre></div>
<p>Then our example class just has to make it easily possible for code that wants to instantiate it to know how to pass its dependencies to it. In Drupal, there are two ways to do this, depending on what you are creating:</p>
<ul><li>Services, which themselves use dependency injection to get their dependencies (as you will see in a minute) have a definition in a YAML file that exactly states which services need to be passed to the service's constructor.</li>
<li>Almost anything else (I think) uses a static <code>create()</code> method which just receives a container of all available services and is then responsible for passing the correct ones to the constructor.</li>
</ul><p>In either case, the idea is that subclasses/replacements of <code>ExampleClass</code> can easily use other dependencies without any changes being necessary to code elsewhere instantiating the class.</p>
<h2>Creating a custom service</h2>
<p>So, when would you want to create your own service in a module? Generally, the <code>.module</code> file should more or less only contain hook implementations now, any general helper functions for the module should live in classes (so they can be easily grouped by functionality, and the code can be lazy-loaded when needed). The decision to make that class into a service then depends on the following questions:</p>
<ul><li>Is there any possibility someone would want to swap out the implementation of the class?</li>
<li>Do you want to unit-test the class?</li>
<li>Relatedly, do you want dependency injection in the class?</li>
</ul><p>I'm not completely sure myself about how to make these decisions, though. We're still thinking about what should and shouldn't be a service in the Search API, currently there is (apart from the ones for plugins) only one service there:</p>
<h3>The "Server task manager" service</h3>
<p>The "server tasks" system, which already existed in D7, basically just ensures that when any operations on a server (e.g., removing or adding an index, deleting items, …) fails for some reason (e.g., Solr is temporarily unreachable) it is regularly retried to always ensure a consistent server state. While in D7 the system consisted of just a few functions, in D8 it was decided to encapsulate the functionality in a dedicated service, the "Server task manager".</p>
<h3>Defining an interface and a class for the service</h3>
<p>The first thing you need, so the service can be properly swapped out later, is an interface specifying exactly what the service should be able to do. This completely depends on your use case for the service, nothing to keep in mind here (and also no special namespace or anything). In our case, for server tasks:</p>
<div class="codeblock">
<pre><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br /></span><span style="color: #007700">namespace </span><span style="color: #0000BB">Drupal</span><span style="color: #007700">\</span><span style="color: #0000BB">search_api</span><span style="color: #007700">\</span><span style="color: #0000BB">Task</span><span style="color: #007700">;<br /><br />interface </span><span style="color: #0000BB">ServerTaskManagerInterface </span><span style="color: #007700">{<br /><br />  public function </span><span style="color: #0000BB">execute</span><span style="color: #007700">(</span><span style="color: #0000BB">ServerInterface $server </span><span style="color: #007700">= </span><span style="color: #0000BB">NULL</span><span style="color: #007700">);<br /><br />  public function </span><span style="color: #0000BB">add</span><span style="color: #007700">(</span><span style="color: #0000BB">ServerInterface $server</span><span style="color: #007700">, </span><span style="color: #0000BB">$type</span><span style="color: #007700">, </span><span style="color: #0000BB">IndexInterface $index </span><span style="color: #007700">= </span><span style="color: #0000BB">NULL</span><span style="color: #007700">, </span><span style="color: #0000BB">$data </span><span style="color: #007700">= </span><span style="color: #0000BB">NULL</span><span style="color: #007700">);<br /><br />  public function </span><span style="color: #0000BB">delete</span><span style="color: #007700">(array </span><span style="color: #0000BB">$ids </span><span style="color: #007700">= </span><span style="color: #0000BB">NULL</span><span style="color: #007700">, </span><span style="color: #0000BB">ServerInterface $server </span><span style="color: #007700">= </span><span style="color: #0000BB">NULL</span><span style="color: #007700">, </span><span style="color: #0000BB">$index </span><span style="color: #007700">= </span><span style="color: #0000BB">NULL</span><span style="color: #007700">);<br /><br />}<br /></span><span style="color: #0000BB">?&gt;</span></span></code></pre></div>
<p>(Of course, proper PhpDocs are essential here, I just skipped them for brevity's sake.)</p>
<p>Then, just create a class implementing the interface. Again, namespace and everything else is completely up to you. In the Search API, we opted to put interface and class (they usually should be in the same namespace) into the namespace <code>\Drupal\search_api\Task</code>. See <a href="http://cgit.drupalcode.org/sandbox-daeron-2091893/tree/src/Task">here</a> for their complete code.<br />
For this post, the only relevant part of the class code is the constructor (the rest just implements the interface's methods):</p>
<div class="codeblock">
<pre><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br /></span><span style="color: #007700">class </span><span style="color: #0000BB">ServerTaskManager </span><span style="color: #007700">implements </span><span style="color: #0000BB">ServerTaskManagerInterface </span><span style="color: #007700">{<br /><br />  public function </span><span style="color: #0000BB">__construct</span><span style="color: #007700">(</span><span style="color: #0000BB">Connection $database</span><span style="color: #007700">, </span><span style="color: #0000BB">EntityManagerInterface $entity_manager</span><span style="color: #007700">) {<br />    </span><span style="color: #0000BB">$this</span><span style="color: #007700">-&gt;</span><span style="color: #0000BB">database </span><span style="color: #007700">= </span><span style="color: #0000BB">$database</span><span style="color: #007700">;<br />    </span><span style="color: #0000BB">$this</span><span style="color: #007700">-&gt;</span><span style="color: #0000BB">entity_manager </span><span style="color: #007700">= </span><span style="color: #0000BB">$entity_manager</span><span style="color: #007700">;<br />  }<br /><br />}<br /></span><span style="color: #0000BB">?&gt;</span></span></code></pre></div>
<p>As you can see, we require the database connection and the entity manager as dependencies, and just included them in the constructor. We then save them to properties to be able to use them later in the other methods.</p>
<p>Now we just need to tell Drupal about our service and its dependencies.</p>
<h3>The <code>services.yml</code> file</h3>
<p>As mentioned earlier, services need a YAML definition to work, where they also specify their dependencies. For this, each module can have a <code>MODULE.services.yml</code> file listing services it wants to publish.</p>
<p>In our case, <code>search_api.services.yml</code> looks like this (with the plugin services removed):</p>
<div class="codeblock"><code>services:<br />  search_api.server_task_manager:<br />    class: Drupal\search_api\Task\ServerTaskManager<br />    arguments: ['@database', '@entity.manager']</code></div>
<p>As you see, it's pretty simple: we assign some ID for the service (<code>search_api.server_task_manager</code> – properly namespaced by having the module name as the first part), specify which class the service uses by default (which, like the other definition keys, <a href="https://www.drupal.org/node/2026959">can then be altered</a> by other modules) and specify the arguments for its constructor (i.e., its dependencies). <code>database</code> and <code>entity.manager</code> in this example are just IDs of other services defined elsewhere (in Drupal core's <code>core.services.yml</code>, in this case).</p>
<p>There are more definition keys available here, and also more features that services support, but that's more or less the gist of it. Once you have its definition in the <code>MODULE.services.yml</code> file, you are ready to use your new service.</p>
<h3>Using a service</h3>
<p>You already know one way of using a service: you can specify it as an argument for another service (or any other dependency injection-enabled component). But what if you want to use it in a hook, or any other place where dependency injection is not available (like entities, annoyingly)?</p>
<p>You simply do this:</p>
<div class="codeblock">
<pre><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br /></span><span style="color: #FF8000">/** @var \Drupal\search_api\Task\ServerTaskManagerInterface $server_task_manager */<br /></span><span style="color: #0000BB">$server_task_manager </span><span style="color: #007700">= \</span><span style="color: #0000BB">Drupal</span><span style="color: #007700">::</span><span style="color: #0000BB">service</span><span style="color: #007700">(</span><span style="color: #DD0000">'search_api.server_task_manager'</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">$server_task_manager</span><span style="color: #007700">-&gt;</span><span style="color: #0000BB">execute</span><span style="color: #007700">();<br /></span><span style="color: #0000BB">?&gt;</span></span></code></pre></div>
<p>That's it, now all our code needing server tasks functionality benefits from dependency injection and all the other Drupal 8 service goodness.</p>
</div></div></div>
  </body>
</html>

