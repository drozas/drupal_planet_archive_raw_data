X-Mozilla-Status: 0000
X-Mozilla-Status2: 00000000
X-Mozilla-Keys:                                                                                
Date: Fri, 06 Dec 2013 12:28:31 +0000
Message-Id: <http://drupal.org/planet/rss.xml#Fri, 06 Dec 2013 12:28:31 +0000@localhost.localdomain>
From: <Drupal Planet>
MIME-Version: 1.0
Subject: Google Code-In student blog: How to create simple module for Drupal 8
Content-Transfer-Encoding: 8bit
Content-Base: http://codein-student.esy.es/?q=node/8
Content-Type: text/html; charset=UTF-8

<html>
  <head>
    <title>Google Code-In student blog: How to create simple module for Drupal 8</title>
    <base href="http://codein-student.esy.es/?q=node/8">
  </head>
  <body id="msgFeedSummaryBody" selected="false">
    <div class="field field-name-field-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item even" rel="og:image rdfs:seeAlso" resource="http://codein-student.esy.es/sites/default/files/styles/large/public/field/image/drupal8-banner.jpg?itok=hTB0ZpId"><img typeof="foaf:Image" src="http://codein-student.esy.es/sites/default/files/styles/large/public/field/image/drupal8-banner.jpg?itok=hTB0ZpId" width="480" height="140" alt="" /></div></div></div><div class="field field-name-body field-type-text-with-summary field-label-hidden"><div class="field-items"><div class="field-item even" property="content:encoded"><p>Hello everybody! In GCI you can often find a task in which you want to create a module for Drupal. Now I will tell you how to do it. Here goes!</p>
<!--break--><p>
Next module will not do anything, but is well suited for example. Its will called 'test'.</p>
<p>Install Drupal 8 via command:</p>
<div class="codeblock"><code>git clone --branch 8.x http://git.drupal.org/project/drupal.git</code></div>
<p>Next let's move on to the test.module file:</p>
<div class="codeblock"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br /><br /></span><span style="color: #FF8000">/**<br /> * @file<br /> * Test<br /> *<br /> */<br /><br />/**<br /> * Implementation of hook_menu()<br /> */<br /></span><span style="color: #007700">function </span><span style="color: #0000BB">test_menu</span><span style="color: #007700">() {<br />  </span><span style="color: #0000BB">$items </span><span style="color: #007700">= array();<br />  <br />  </span><span style="color: #0000BB">$items</span><span style="color: #007700">[</span><span style="color: #DD0000">'test/{variable}'</span><span style="color: #007700">] = array(<br />    </span><span style="color: #DD0000">'title' </span><span style="color: #007700">=&gt; </span><span style="color: #DD0000">'Test'</span><span style="color: #007700">,<br />    </span><span style="color: #DD0000">'route_name' </span><span style="color: #007700">=&gt; </span><span style="color: #DD0000">'test_page'</span><span style="color: #007700">,<br />    </span><span style="color: #DD0000">'type' </span><span style="color: #007700">=&gt; </span><span style="color: #0000BB">MENU_DEFAULT_LOCAL_TASK</span><span style="color: #007700">,<br />  );<br />  <br />  return </span><span style="color: #0000BB">$items</span><span style="color: #007700">;<br />}<br /></span><span style="color: #0000BB">?&gt;</span></span></code></div>
<p>One of the first things you'll notice if you're paying attention is that there are no block hooks in the .module file anymore. That's because blocks in Drupal 8 are plugins. We'll get to that in a few moments. The other thing you'll notice is that the hook_menu implementation doesn't have any callback information. In Drupal 8, as part of the WSCCI, those old procedural callbacks have been swapped out for an OO Symfony2 routing system. hook_menu is still there, but now it's ONLY used to define menu items, NOT to define their paths, or routes as it were. You can see that there's a new key in the array called 'routing_name'. Remember this as it'll be important in a few minutes. You can also see that the old argument placeholder, %, is now replaced by a bracket syntax: {variable_name}. This variable_name will be automatically passed as $variable_name to the callback method that we will define in our route controller class. What's a route controller class you say? Well, the way it works now is that we'll create another yaml file (called modulename.routing.yml) to map any incoming request path to a method contained within a controller class for this module.</p>
<p>The route controller class is stored in the file system according to the much maligned PSR-0 standard for autoloading code only when it's needed. I won't get into this too much, but it basically consists of the idea that your file system should be structured in a standard way. For Drupal 8's routing controller, this means having a directory structure starting at your modulename root directory that looks like lib/Drupal/modulename/Controller/ControllerName.php. If you think having to adhere to such a long and redundant file structure is ridiculous, you're not alone. The plan as of now is to move to the slightly less-ridiculous forthcoming proposed PSR-4 for class loading, but I digress...</p>
<p>Let's take a look at the test.routing.yml file:</p>
<div class="codeblock"><code>test_page:<br />  pattern: '/test/{variable}'<br />  defaults:<br />    _content: 'Drupal\test\Controller\TestController::testPage'<br />  requirements:<br />    _permission: 'access content'</code></div>
<p>Remember the routing_name =&gt; 'test_page' in the $items[] array from test.module? You can see that it is used here as the unique name for this route. We then define the pattern to match for the incoming request, and as you can see it contains the {variable} placeholder. Next, in the _content variable of the defaults section we reference the Controller class and method that will be called when this route is matched. Referencing this method in '_content' means that Drupal will wrap whatever is returned from this method with the rest of the page layout. Lastly, we set the required permission needed to access this page.<br />
Next we need to create the route controller class that we referenced in the test.routing.yml file. So, make sure you have the directory structure as I described above (to adhere to the PSR-0 “standard”). Starting at test (your module directory) the filesystem should be structured like 'test/lib/Drupal/test/Controller'. Inside that last 'Controller' directory, you'll create your TestController.php file like this:</p>
<div class="codeblock"><code>&lt;?php<br /><br />namespace Drupal\test\Controller;<br /><br />class TestController {<br />  <br />  public function testPage($variable) {<br />    $build = array(<br />      '#type' =&gt; 'markup',<br />      '#markup' =&gt; t($variable),<br />    );<br />    <br />    return $build;<br />  }<br />}</code></div>
<p>As you can see, this is a pretty standard php class file. I've defined the testPage method (as it was referenced in the test.routing.yml file), and it returns a build array. The interesting thing to note here is that as I described earlier, the $variable that is passed into the testPage method is the argument that comes in on the url when the route is fired. So if you now go to your drupal 8 site and navigate to admin/config/development/performance, then clear all caches, then navigate to admin/modules and enable the test.module, you should then be able to navigate to <a href="http://yoursite/test/it-works">http://yoursite/test/it-works</a>, and see a page that just prints out $variable (“it-works”). Please note that this is an extremely simplified example. I'm not taking dependency injection into account at all. That would require a bit more code. We'd need the TestController class to implement the ControllerInterface interface. For now, I'll leave that to you, but I might revisit dependency injection in a future blog post.<br />
Now that we've sorted the routing, let's look at how to create a custom block in our test module. In Drupal 8, blocks are plugins, so to create a custom block we'll need to create a Plugin and a Block directory in our file structure. Change into the test/lib/Drupal/test directory and do</p>
<div class="codeblock"><code>mkdir -p ./Plugin/Block</code></div>
<p>Now you should have a directory structure like 'test/lib/Drupal/test/Plugin/Block'. In that Block directory, we'll create our TestBlock.php file. The file looks like this:</p>
<div class="codeblock"><code>&lt;?php<br /><br />/**<br /> * @file<br /> * Contains \Drupal\test\Plugin\Block\TestBlock<br /> */<br /><br />namespace Drupal\test\Plugin\Block;<br /><br />use Drupal\block\BlockBase;<br />use Drupal\block\Annotation\Block;<br />use Drupal\Core\Annotation\Translation;<br /><br />/**<br /> * Provides a test block.<br /> *<br /> * @Block(<br /> *  id = "test_block",<br /> *  admin_label = @Translation("Test Block")<br /> * )<br /> */<br />class TestBlock extends BlockBase {<br />  /**<br />   * {@inheritdoc}<br />   */<br />  public function build() {<br />    $this-&gt;configuration['label'] = t('Test block');<br />    return array(<br />      '#children' =&gt; t('Here is the content'),<br />    );<br />  }<br />}</code></div>
<p> Again, this is a pretty standard php class. TestBlock extends the BlockBase class. BlockBase has a number of methods that can be overridden here to do all sorts of cool things with your custom blocks. </p>
</div></div></div><div class="field field-name-field-tags field-type-taxonomy-term-reference field-label-above clearfix"><h3 class="field-label">Tags: </h3><ul class="links"><li class="taxonomy-term-reference-0" rel="dc:subject"><a href="/?q=taxonomy/term/2" typeof="skos:Concept" property="rdfs:label skos:prefLabel" datatype="">drupal-planet</a></li><li class="taxonomy-term-reference-1" rel="dc:subject"><a href="/?q=taxonomy/term/3" typeof="skos:Concept" property="rdfs:label skos:prefLabel" datatype="">Drupal</a></li></ul></div>
  </body>
</html>

