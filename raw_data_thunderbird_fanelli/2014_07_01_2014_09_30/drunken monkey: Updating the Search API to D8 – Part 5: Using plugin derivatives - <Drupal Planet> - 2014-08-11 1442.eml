X-Mozilla-Status: 0041
X-Mozilla-Status2: 00000000
X-Mozilla-Keys:                                                                                
Date: Mon, 11 Aug 2014 12:42:00 +0000
Message-Id: <http://drupal.org/planet/rss.xml#Mon, 11 Aug 2014 12:42:00 +0000@localhost.localdomain>
From: <Drupal Planet>
MIME-Version: 1.0
Subject: drunken monkey: Updating the Search API to D8 – Part 5: Using plugin derivatives
Content-Transfer-Encoding: 8bit
Content-Base: http://drunkenmonkey.at/blog/search-api-d8-update-part-5
Content-Type: text/html; charset=UTF-8

<html>
  <head>
    <title>drunken monkey: Updating the Search API to D8 – Part 5: Using plugin derivatives</title>
    <base href="http://drunkenmonkey.at/blog/search-api-d8-update-part-5">
  </head>
  <body id="msgFeedSummaryBody" selected="false">
    <div class="field field-name-field-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item even"><img typeof="foaf:Image" src="http://drunkenmonkey.at/sites/default/files/styles/medium/public/field_image/mona-lisa.jpg?itok=4hVXrCMs" width="159" height="240" alt="" title="Derivatives: usually, but not always a bad thing." /></div></div></div><div class="field field-name-body field-type-text-with-summary field-label-hidden"><div class="field-items"><div class="field-item even" property="content:encoded"><p>The greatest thing about all the refactoring in Drupal 8 is that, in general, a lot of those special Drupalisms used nowhere else were thrown out and replaced by sound design patterns, industry best practices and concepts that newcomers from other branches of programming will have an easy time of recognizing and using. While I can understand that this is an annoyance for some who have got used to the Drupalisms (and who haven't got a formal education in programming), as someone with a CS degree and a background in Java I was overjoyed at almost anything new I learned about Drupal 8, which, in my opinion, just made Drupal so much cleaner.<br />
But, of course, this has already been discussed in a lot of other blog posts, podcasts, sessions, etc., by a lot of other people.</p>
<p>What I want to discuss today is one of the few instances where it seems this principle was violated and a new Drupalism, not known anywhere else (as far as I can tell, at least – if I'm mistaken I'd be grateful to be educated in the comments), introduced: plugin derivatives.<br />
Probably some of you have already seen it there somewhere, especially if you were foolish enough to try to understand the new block system (if you succeeded, I salute you!), but I bet (or, hope) most of you had the same reaction as me: a very puzzled look and an involuntary “What the …?” In my case, this question was all the more pressing because I first stumbled upon plugin derivatives <em>in my own module</em> – <a href="https://www.drupal.org/user/1455470">Frédéric Hennequin</a> had done a lot of the initial work of porting the module and since there was a place where they fit perfectly, he used them. Luckily, I came across this in <a href="http://szeged2014.drupaldays.org/program/code-sprints/search-api-drupal-8">Szeged</a> where <a href="https://www.drupal.org/user/172527">Bram Goffings</a> was close by and could explain this to me slowly until it sank in. (Looking at the <a href="https://www.drupal.org/node/1653226">handbook documentation</a> now, it actually looks quite good, but I remember that, back then, I had no idea what they were talking about.)<br />
So, without (even) further ado, let me now share this arcane knowledge with you!</p>
<h2>What, and <em>why</em>, are plugin derivatives?</h2>
<h3>The problem</h3>
<p>Plugin derivatives, even though very Drupalistic (?), are actually a rather elegant solution for an interesting (and pressing) problem: dynamically defining plugins.<br />
For example, take Search API's "datasource" plugins. These provide item types that can be indexed by the Search API, a further abstraction from the "entity" concept to be able to handle non-entities (or, indeed, even non-Drupal content). We of course want to provide an item type for each entity type, but we don't know beforehand which entity types there will be on a site – also, since entities can be accessed with a common API we can use the same code for all entity types and don't want a new class for each.<br />
In Drupal 7, this was trivial to do:</p>
<div class="codeblock">
<pre><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br /></span><span style="color: #FF8000">/**<br /> * Implements hook_search_api_item_type_info().<br /> */<br /></span><span style="color: #007700">function </span><span style="color: #0000BB">search_api_search_api_item_type_info</span><span style="color: #007700">() {<br />  </span><span style="color: #0000BB">$types </span><span style="color: #007700">= array();<br />  foreach (</span><span style="color: #0000BB">entity_get_property_info</span><span style="color: #007700">() as </span><span style="color: #0000BB">$type </span><span style="color: #007700">=&gt; </span><span style="color: #0000BB">$property_info</span><span style="color: #007700">) {<br />    if (</span><span style="color: #0000BB">$info </span><span style="color: #007700">= </span><span style="color: #0000BB">entity_get_info</span><span style="color: #007700">(</span><span style="color: #0000BB">$type</span><span style="color: #007700">)) {<br />      </span><span style="color: #0000BB">$types</span><span style="color: #007700">[</span><span style="color: #0000BB">$type</span><span style="color: #007700">] = array(<br />        </span><span style="color: #DD0000">'name' </span><span style="color: #007700">=&gt; </span><span style="color: #0000BB">$info</span><span style="color: #007700">[</span><span style="color: #DD0000">'label'</span><span style="color: #007700">],<br />        </span><span style="color: #DD0000">'datasource controller' </span><span style="color: #007700">=&gt; </span><span style="color: #DD0000">'SearchApiEntityDataSourceController'</span><span style="color: #007700">,<br />        </span><span style="color: #DD0000">'entity_type' </span><span style="color: #007700">=&gt; </span><span style="color: #0000BB">$type</span><span style="color: #007700">,<br />      );<br />    }<br />  }<br />  return </span><span style="color: #0000BB">$types</span><span style="color: #007700">;<br />}<br /></span><span style="color: #0000BB">?&gt;</span></span></code></pre></div>
<p>Since plugin definition happens in a hook, we can just loop over all entity types, set the same controller class for each, and put an additional <code>entity_type</code> key into the definition so the controller knows which entity type it should use.</p>
<p>Now, in Drupal 8, there's a problem: as discussed <a href="http://drunkenmonkey.at/blog/search-api-d8-update-part-4">in the previous part of this series</a>, plugins now generally use annotations on the plugin class for the definition. That, in turn, would mean that a single class can only represent a single plugin, and since you can't (or at least really, <em>really</em> shouldn't) dynamically define classes there's also not really any way to dynamically define plugins.<br />
One possible workaround would be to just use the alter hook which comes with nearly any plugin type and dynamically add the desired plugins there – however, that's not really ideal as a general solution for the problem, especially since it also occurs in core in several places. (The clearest example here are probably menu blocks – for each menu, you want one block plugin defined.)</p>
<h3>The solution</h3>
<p>So, as you might have guessed, the solution to this problem was the introduction of the concept of <em>derivatives</em>. Basically, every time you define a new plugin of any type (as long as the manager inherits from <a href="https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Plugin!DefaultPluginManager.php/class/DefaultPluginManager/8"><code>DefaultPluginManager</code></a> you can add a <code>deriver</code> key to its definition, referencing a class. This deriver class will then automatically be called when the plugin system looks for plugins of that type and allows the deriver to multiply the plugin's definition, adding or altering any definition keys as appropriate. It is, essentially, another layer of altering that is specific to one plugin, serves a specific purpose (i.e., multiplying that plugin's definition) and occurs before the general alter hook is invoked.</p>
<p>Hopefully, an example will make this clearer. Let's see how we used this system in the Search API to solve the above problem with datasources.</p>
<h2>How to use derivatives</h2>
<p>So, how do we define several datasource plugins with a single class? Once you understand how it works (or what it's supposed to do) it's thankfully pretty easy to do. We first create our plugin like normally (or, just copy it from Drupal 7 and fix class name and namespace), but add the <code>deriver</code> key and internally assume that the plugin definition has an additional <code>entity_type</code> key which will tell us which entity type this specific datasource plugin should work with.</p>
<p>So, we put the following into <a href="http://cgit.drupalcode.org/sandbox-daeron-2091893/tree/src/Plugin/SearchApi/Datasource/ContentEntityDatasource.php"><code>src/Plugin/SearchApi/Datasource/ContentEntityDatasource.php</code></a>:</p>
<div class="codeblock">
<pre><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br /></span><span style="color: #007700">namespace </span><span style="color: #0000BB">Drupal</span><span style="color: #007700">\</span><span style="color: #0000BB">search_api</span><span style="color: #007700">\</span><span style="color: #0000BB">Plugin</span><span style="color: #007700">\</span><span style="color: #0000BB">SearchApi</span><span style="color: #007700">\</span><span style="color: #0000BB">Datasource</span><span style="color: #007700">;<br /><br /></span><span style="color: #FF8000">/**<br /> * @SearchApiDatasource(<br /> *   id = "entity",<br /> *   deriver = "Drupal\search_api\Plugin\SearchApi\Datasource\ContentEntityDatasourceDeriver"<br /> * )<br /> */<br /></span><span style="color: #007700">class </span><span style="color: #0000BB">ContentEntityDatasource </span><span style="color: #007700">extends </span><span style="color: #0000BB">DatasourcePluginBase </span><span style="color: #007700">{<br /><br />  public function </span><span style="color: #0000BB">loadMultiple</span><span style="color: #007700">(array </span><span style="color: #0000BB">$ids</span><span style="color: #007700">) {<br />    </span><span style="color: #FF8000">// In the real code, this of course uses dependency injection, not a global function.<br />    </span><span style="color: #007700">return </span><span style="color: #0000BB">entity_load_multiple</span><span style="color: #007700">(</span><span style="color: #0000BB">$this</span><span style="color: #007700">-&gt;</span><span style="color: #0000BB">pluginDefinition</span><span style="color: #007700">[</span><span style="color: #DD0000">'entity_type'</span><span style="color: #007700">], </span><span style="color: #0000BB">$ids</span><span style="color: #007700">);<br />  }<br /><br />  </span><span style="color: #FF8000">// Plus a lot of other methods …<br /><br /></span><span style="color: #007700">}<br /></span><span style="color: #0000BB">?&gt;</span></span></code></pre></div>
<p>Note that, even though we can skip even required keys in the definition (like <code>label</code> here), we still have to set an <code>id</code>. This is called the "plugin base ID" and will be used as a prefix to all IDs of the derivative plugin definitions, as we'll see in a bit.<br />
The <code>deriver</code> key is of course the main thing here. The namespace and name are arbitrary (the standard is to use the same namespace as the plugin itself, but append "Deriver" to the class name), the class just needs to implement the <a href="https://api.drupal.org/api/drupal/core!lib!Drupal!Component!Plugin!Derivative!DeriverInterface.php/interface/DeriverInterface/8"><code>DeriverInterface</code></a> – nothing else is needed. There is also <a href="https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Plugin!Discovery!ContainerDeriverInterface.php/interface/ContainerDeriverInterface/8"><code>ContainerDeriverInterface</code></a>, a sub-interface for when you want dependency injection for creating the deriver, and an abstract base class, <a href="https://api.drupal.org/api/drupal/core!lib!Drupal!Component!Plugin!Derivative!DeriverBase.php/class/DeriverBase/8"><code>DeriverBase</code></a>, which isn't very useful though, since the interface only has two methods. Concretely, the two methods are: <code>getDerivativeDefinitions()</code>, for getting all derivative definitions, and <code>getDerivativeDefinition()</code> for getting a single one – the latter usually simply a two-liner using the former.</p>
<p>Therefore, this is what <a href="http://cgit.drupalcode.org/sandbox-daeron-2091893/tree/src/Plugin/SearchApi/Datasource/ContentEntityDatasourceDeriver.php"><code>src/Plugin/SearchApi/Datasource/ContentEntityDatasourceDeriver.php</code></a> looks like:</p>
<div class="codeblock">
<pre><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br /></span><span style="color: #007700">namespace </span><span style="color: #0000BB">Drupal</span><span style="color: #007700">\</span><span style="color: #0000BB">search_api</span><span style="color: #007700">\</span><span style="color: #0000BB">Plugin</span><span style="color: #007700">\</span><span style="color: #0000BB">SearchApi</span><span style="color: #007700">\</span><span style="color: #0000BB">Datasource</span><span style="color: #007700">;<br /><br />class </span><span style="color: #0000BB">ContentEntityDatasourceDeriver </span><span style="color: #007700">implements </span><span style="color: #0000BB">DeriverInterface </span><span style="color: #007700">{<br /><br />  public function </span><span style="color: #0000BB">getDerivativeDefinition</span><span style="color: #007700">(</span><span style="color: #0000BB">$derivative_id</span><span style="color: #007700">, </span><span style="color: #0000BB">$base_plugin_definition</span><span style="color: #007700">) {<br />    </span><span style="color: #0000BB">$derivatives </span><span style="color: #007700">= </span><span style="color: #0000BB">$this</span><span style="color: #007700">-&gt;</span><span style="color: #0000BB">getDerivativeDefinitions</span><span style="color: #007700">(</span><span style="color: #0000BB">$base_plugin_definition</span><span style="color: #007700">);<br />    return isset(</span><span style="color: #0000BB">$derivatives</span><span style="color: #007700">[</span><span style="color: #0000BB">$derivative_id</span><span style="color: #007700">]) ? </span><span style="color: #0000BB">$derivatives</span><span style="color: #007700">[</span><span style="color: #0000BB">$derivative_id</span><span style="color: #007700">] : </span><span style="color: #0000BB">NULL</span><span style="color: #007700">;<br />  }<br /><br />  public function </span><span style="color: #0000BB">getDerivativeDefinitions</span><span style="color: #007700">(</span><span style="color: #0000BB">$base_plugin_definition</span><span style="color: #007700">) {<br />    </span><span style="color: #0000BB">$base_plugin_id </span><span style="color: #007700">= </span><span style="color: #0000BB">$base_plugin_definition</span><span style="color: #007700">[</span><span style="color: #DD0000">'id'</span><span style="color: #007700">];<br />    </span><span style="color: #0000BB">$plugin_derivatives </span><span style="color: #007700">= array();<br />    foreach (\</span><span style="color: #0000BB">Drupal</span><span style="color: #007700">::</span><span style="color: #0000BB">entityManager</span><span style="color: #007700">()-&gt;</span><span style="color: #0000BB">getDefinitions</span><span style="color: #007700">() as </span><span style="color: #0000BB">$entity_type_id </span><span style="color: #007700">=&gt; </span><span style="color: #0000BB">$entity_type_definition</span><span style="color: #007700">) {<br />      if (</span><span style="color: #0000BB">$entity_type_definition </span><span style="color: #007700">instanceof </span><span style="color: #0000BB">ContentEntityType</span><span style="color: #007700">) {<br />        </span><span style="color: #0000BB">$label </span><span style="color: #007700">= </span><span style="color: #0000BB">$entity_type_definition</span><span style="color: #007700">-&gt;</span><span style="color: #0000BB">getLabel</span><span style="color: #007700">();<br />        </span><span style="color: #0000BB">$plugin_derivatives</span><span style="color: #007700">[</span><span style="color: #0000BB">$entity_type_id</span><span style="color: #007700">] = array(<br />          </span><span style="color: #DD0000">'id' </span><span style="color: #007700">=&gt; </span><span style="color: #0000BB">$base_plugin_id </span><span style="color: #007700">. </span><span style="color: #0000BB">PluginBase</span><span style="color: #007700">::</span><span style="color: #0000BB">DERIVATIVE_SEPARATOR </span><span style="color: #007700">. </span><span style="color: #0000BB">$entity_type_id</span><span style="color: #007700">,<br />          </span><span style="color: #DD0000">'label' </span><span style="color: #007700">=&gt; </span><span style="color: #0000BB">$label</span><span style="color: #007700">,<br />          </span><span style="color: #DD0000">'description' </span><span style="color: #007700">=&gt; </span><span style="color: #0000BB">$this</span><span style="color: #007700">-&gt;</span><span style="color: #0000BB">t</span><span style="color: #007700">(</span><span style="color: #DD0000">'Provides %entity_type entities for indexing and searching.'</span><span style="color: #007700">, array(</span><span style="color: #DD0000">'%entity_type' </span><span style="color: #007700">=&gt; </span><span style="color: #0000BB">$label</span><span style="color: #007700">)),<br />          </span><span style="color: #DD0000">'entity_type' </span><span style="color: #007700">=&gt; </span><span style="color: #0000BB">$entity_type_id</span><span style="color: #007700">,<br />        ) + </span><span style="color: #0000BB">$base_plugin_definition</span><span style="color: #007700">;<br />      }<br />    }<br />    return </span><span style="color: #0000BB">$plugin_derivatives</span><span style="color: #007700">;<br />  }<br /><br />}<br /></span><span style="color: #0000BB">?&gt;</span></span></code></pre></div>
<p>As you see, <code>getDerivativeDefinitions()</code> just returns an array with derivative plugin definitions – keyed by what's called their "derivative ID" and their <code>id</code> key set to a combination of base ID and derivative ID, separated by <a href="https://api.drupal.org/api/drupal/core!lib!Drupal!Component!Plugin!PluginBase.php/constant/PluginBase%3A%3ADERIVATIVE_SEPARATOR/8"><code>PluginBase::DERIVATIVE_SEPARATOR</code></a> (which is simply a colon (":")). We additionally set the <code>entity_type</code> key for all definitions (as we used in the plugin) and also set the other definition keys (as defined in the annotation) accordingly.</p>
<p>And that's it! If your plugin type implements <a href="https://api.drupal.org/api/drupal/core!lib!Drupal!Component!Plugin!DerivativeInspectionInterface.php/interface/DerivativeInspectionInterface/8"><code>DerivativeInspectionInterface</code></a> (which the normal <a href="https://api.drupal.org/api/drupal/core!lib!Drupal!Component!Plugin!PluginBase.php/class/PluginBase/8"><code>PluginBase</code></a> class does), you also have handy methods for finding out a plugin's base ID and derivative ID (if any). But usually the code using the plugins doesn't need to be aware of derivatives and can simply handle them like any other plugin. Just be aware that this leads to plugin IDs now all potentially containing colons, and not only the usual "alphanumerics plus underscores" ID characters.</p>
<h3>A side note about nomenclature</h3>
<p>This is a bit confusing actually, especially as older documentation remains unupdated: The new individual plugins that were derived from the base defintion are referred to as "derivative plugin definitions", "plugin derivatives" or just "derivatives". Confusingly, though, the class creating the derivatives was <em>also</em> called a "derivative class" (and the key in the plugin definition was, consequently, <code>derivative</code>).<br />
In <a href="https://www.drupal.org/node/1875996">#1875996: Reconsider naming conventions for derivative classes</a>, this discrepancy was discussed and eventually resolved by renaming the classes creating derivative definitions (along with their interfaces, etc.) to "derivers".<br />
If you are reading documentation that is more than a few months old, hopefully this will prevent you from some confusion.</p>
<p><small>Image credit: <a href="https://secure.flickr.com/photos/donkeyhotey/6432459465">DonkeyHotey</a></small></p>
</div></div></div>
  </body>
</html>

